"use strict";

var warp10Finalize = require("warp10/finalize");
var eventDelegation = require("./event-delegation");
var win = window;
var defaultDocument = document;
var createFragmentNode = require("../vdom/morphdom/fragment").am_;
var componentsUtil = require("./util");
var componentLookup = componentsUtil.F_;
var addComponentRootToKeyedElements = componentsUtil.an_;
var ComponentDef = require("./ComponentDef");
var registry = require("./registry");
var domData = require("./dom-data");
var keyedElementsByComponentId = domData.J_;
var componentsByDOMNode = domData.I_;
var serverRenderedGlobals = {};
var serverComponentRootNodes = {};

var FLAG_WILL_RERENDER_IN_BROWSER = 1;

function indexServerComponentBoundaries(node, runtimeId, stack) {
  var componentId;
  var ownerId;
  var ownerComponent;
  var keyedElements;
  var nextSibling;
  var runtimeLength = runtimeId.length;
  stack = stack || [];

  node = node.firstChild;
  while (node) {
    nextSibling = node.nextSibling;
    if (node.nodeType === 8) {
      // Comment node
      var commentValue = node.nodeValue;
      if (commentValue.slice(0, runtimeLength) === runtimeId) {
        var firstChar = commentValue[runtimeLength];

        if (firstChar === "^" || firstChar === "#") {
          stack.push(node);
        } else if (firstChar === "/") {
          var endNode = node;
          var startNode = stack.pop();
          var rootNode;

          if (startNode.parentNode === endNode.parentNode) {
            rootNode = createFragmentNode(startNode.nextSibling, endNode);
          } else {
            rootNode = createFragmentNode(endNode.parentNode.firstChild, endNode);
          }

          componentId = startNode.nodeValue.substring(runtimeLength + 1);
          firstChar = startNode.nodeValue[runtimeLength];

          if (firstChar === "^") {
            var parts = componentId.split(/ /g);
            var key = parts[2];
            ownerId = parts[1];
            componentId = parts[0];
            if (ownerComponent = componentLookup[ownerId]) {
              keyedElements = ownerComponent.o_;
            } else {
              keyedElements = keyedElementsByComponentId[ownerId] || (keyedElementsByComponentId[ownerId] = {});
            }
            addComponentRootToKeyedElements(keyedElements, key, rootNode, componentId);
          }

          serverComponentRootNodes[componentId] = rootNode;

          startNode.parentNode.removeChild(startNode);
          endNode.parentNode.removeChild(endNode);
        }
      }
    } else if (node.nodeType === 1) {
      // HTML element node
      var markoKey = node.getAttribute("data-marko-key");
      var markoProps = node.getAttribute("data-marko");
      if (markoKey) {
        var separatorIndex = markoKey.indexOf(" ");
        ownerId = markoKey.substring(separatorIndex + 1);
        markoKey = markoKey.substring(0, separatorIndex);
        if (ownerComponent = componentLookup[ownerId]) {
          keyedElements = ownerComponent.o_;
        } else {
          keyedElements = keyedElementsByComponentId[ownerId] || (keyedElementsByComponentId[ownerId] = {});
        }
        keyedElements[markoKey] = node;
      }
      if (markoProps) {
        markoProps = JSON.parse(markoProps);
        Object.keys(markoProps).forEach(function (key) {
          if (key.slice(0, 2) === "on") {
            eventDelegation._A_(key.slice(2));
          }
        });
      }
      indexServerComponentBoundaries(node, runtimeId, stack);
    }

    node = nextSibling;
  }
}

function invokeComponentEventHandler(component, targetMethodName, args) {
  var method = component[targetMethodName];
  if (!method) {
    throw Error("Method not found: " + targetMethodName);
  }

  method.apply(component, args);
}

function addEventListenerHelper(el, eventType, isOnce, listener) {
  var eventListener = listener;
  if (isOnce) {
    eventListener = function (event) {
      listener(event);
      el.removeEventListener(eventType, eventListener);
    };
  }

  el.addEventListener(eventType, eventListener, false);

  return function remove() {
    el.removeEventListener(eventType, eventListener);
  };
}

function addDOMEventListeners(component, el, eventType, targetMethodName, isOnce, extraArgs, handles) {
  var removeListener = addEventListenerHelper(el, eventType, isOnce, function (event) {
    var args = [event, el];
    if (extraArgs) {
      args = extraArgs.concat(args);
    }

    invokeComponentEventHandler(component, targetMethodName, args);
  });
  handles.push(removeListener);
}

function initComponent(componentDef, doc) {
  var component = componentDef.m_;

  if (!component || !component._a_) {
    return; // legacy
  }

  component.L_();
  component.___ = doc;

  var isExisting = componentDef._D_;

  if (isExisting) {
    component._d_();
  }

  var domEvents = componentDef._C_;
  if (domEvents) {
    var eventListenerHandles = [];

    domEvents.forEach(function (domEventArgs) {
      // The event mapping is for a direct DOM event (not a custom event and not for bubblign dom events)

      var eventType = domEventArgs[0];
      var targetMethodName = domEventArgs[1];
      var eventEl = component.o_[domEventArgs[2]];
      var isOnce = domEventArgs[3];
      var extraArgs = domEventArgs[4];

      addDOMEventListeners(component, eventEl, eventType, targetMethodName, isOnce, extraArgs, eventListenerHandles);
    });

    if (eventListenerHandles.length) {
      component.P_ = eventListenerHandles;
    }
  }

  if (component.U_) {
    component.G_("update");
  } else {
    component.U_ = true;
    component.G_("mount");
  }
}

/**
 * This method is used to initialized components associated with UI components
 * rendered in the browser. While rendering UI components a "components context"
 * is added to the rendering context to keep up with which components are rendered.
 * When ready, the components can then be initialized by walking the component tree
 * in the components context (nested components are initialized before ancestor components).
 * @param  {Array<marko-components/lib/ComponentDef>} componentDefs An array of ComponentDef instances
 */
function initClientRendered(componentDefs, doc) {
  // Ensure that event handlers to handle delegating events are
  // always attached before initializing any components
  eventDelegation.ai_(doc);

  doc = doc || defaultDocument;
  var len = componentDefs.length;
  var componentDef;
  var i;

  for (i = len; i--;) {
    componentDef = componentDefs[i];
    trackComponent(componentDef);
  }

  for (i = len; i--;) {
    componentDef = componentDefs[i];
    initComponent(componentDef, doc);
  }
}

/**
 * This method initializes all components that were rendered on the server by iterating over all
 * of the component IDs.
 */
function initServerRendered(renderedComponents, doc) {
  var type = typeof renderedComponents;
  var runtimeId;

  if (type !== "object") {
    var componentsKey = "$" + (type === "string" ? renderedComponents + "_components" : "components");
    renderedComponents = win[componentsKey];

    if (renderedComponents && renderedComponents.forEach) {
      renderedComponents.forEach(function (renderedComponent) {
        initServerRendered(renderedComponent, doc);
      });
    }

    win[componentsKey] = {
      concat: initServerRendered
    };

    return;
  }

  doc = doc || defaultDocument;

  renderedComponents = warp10Finalize(renderedComponents);

  runtimeId = renderedComponents.r;
  var componentDefs = renderedComponents.w;
  var typesArray = renderedComponents.t;
  var markoGlobalsKey = "$" + runtimeId + "G";

  // Ensure that event handlers to handle delegating events are
  // always attached before initializing any components
  indexServerComponentBoundaries(doc, runtimeId);
  eventDelegation.ai_(doc);

  var globals = win[markoGlobalsKey];
  if (globals) {
    serverRenderedGlobals = warp10Finalize(globals);
    delete win[markoGlobalsKey];
  }

  // hydrate components top down (leaf nodes last)
  // and return an array of functions to mount these components
  var deferredDefs;
  componentDefs.map(function (componentDef) {
    componentDef = ComponentDef._K_(componentDef, typesArray, serverRenderedGlobals, registry);

    var mount = hydrateComponentAndGetMount(componentDef, doc);

    if (!mount) {
      // hydrateComponentAndGetMount will return false if there is not rootNode
      // for the component.  If this is the case, we'll wait until the
      // DOM has fully loaded to attempt to init the component again.
      if (deferredDefs) {
        deferredDefs.push(componentDef);
      } else {
        deferredDefs = [componentDef];
        doc.addEventListener("DOMContentLoaded", function () {
          indexServerComponentBoundaries(doc, runtimeId);
          deferredDefs.map(function (componentDef) {
            return hydrateComponentAndGetMount(componentDef, doc);
          }).reverse().forEach(tryInvoke);
        });
      }
    }

    return mount;
  }).reverse().forEach(tryInvoke);
}

function hydrateComponentAndGetMount(componentDef, doc) {
  var componentId = componentDef.id;
  var component = componentDef.m_;
  var rootNode = serverComponentRootNodes[componentId];
  var renderResult;

  if (rootNode) {
    delete serverComponentRootNodes[componentId];

    component.N_ = rootNode;
    componentsByDOMNode.set(rootNode, component);

    if (componentDef._F_ & FLAG_WILL_RERENDER_IN_BROWSER) {
      component.___ = doc;
      renderResult = component._r_(component.T_, true);
      trackComponent(componentDef);
      return function mount() {
        renderResult.afterInsert(doc);
      };
    } else {
      trackComponent(componentDef);
    }

    return function mount() {
      initComponent(componentDef, doc);
    };
  }
}

function trackComponent(componentDef) {
  var component = componentDef.m_;
  if (component) {
    componentLookup[component.id] = component;
  }
}

function tryInvoke(fn) {
  if (fn) fn();
}

exports._Q_ = initClientRendered;
exports.ak_ = initServerRendered;