var nextTick = require("../../../runtime/nextTick");

function AsyncValue() {
  /**
   * The data that was provided via call to resolve(data).
   * This property is assumed to be public and available for inspection.
   */
  this.t_ = undefined;

  /**
   * The data that was provided via call to reject(err)
   * This property is assumed to be public and available for inspection.
   */
  this.u_ = undefined;

  /**
   * The queue of callbacks that are waiting for data
   */
  this.v_ = undefined;

  /**
   * The state of the data holder (STATE_INITIAL, STATE_RESOLVED, or STATE_REJECTED)
   */
  this.w_ = false;
}

function notifyCallbacks(asyncValue, err, value) {
  var callbacks = asyncValue.v_;
  if (callbacks) {
    // clear out the registered callbacks (we still have reference to the original value)
    asyncValue.v_ = undefined;

    // invoke all of the callbacks and use their scope
    for (var i = 0; i < callbacks.length; i++) {
      // each callback is actually an object with "scope and "callback" properties
      var callback = callbacks[i];
      callback(err, value);
    }
  }
}

AsyncValue.prototype = {
  /**
   * Adds a callback to the queue. If there is not a pending request to load data
   * and we have a "loader" then we will use that loader to request the data.
   * The given callback will be invoked when there is an error or resolved data
   * available.
   */
  x_: function (callback) {
    // Do we already have data or error?
    if (this.w_) {
      // invoke the callback immediately
      return callback(this.u_, this.t_);
    }

    var callbacks = this.v_ || (this.v_ = []);
    callbacks.push(callback);
  },

  /**
   * This method will trigger any callbacks to be notified of rejection (error).
   * If this data holder has a loader then the data holder will be returned to
   * its initial state so that any future requests to load data will trigger a
   * new load call.
   */
  y_: function (err) {
    if (this.w_) {
      return;
    }

    // remember the error
    this.u_ = err;

    // Go to the rejected state if we don't have a loader.
    // If we do have a loader then return to the initial state
    // (we do this so that next call to done() will trigger load
    // again in case the error was transient).
    this.w_ = true;

    // always notify callbacks regardless of whether or not we return to the initial state
    notifyCallbacks(this, err, null);
  },

  /**
   * This method will trigger any callbacks to be notified of data.
   */
  z_: function (value) {
    if (this.w_) {
      return;
    }

    if (value && typeof value.then === "function") {
      var asyncValue = this;

      var finalPromise = value.then(function onFulfilled(value) {
        nextTick(asyncValue.z_.bind(asyncValue, value));
      }, function onRejected(err) {
        nextTick(asyncValue.y_.bind(asyncValue, err));
      });

      if (finalPromise.done) {
        finalPromise.done();
      }
    } else {
      // remember the state
      this.t_ = value;

      // go to the resolved state
      this.w_ = true;

      // notify callbacks
      notifyCallbacks(this, null, value);
    }
  }
};

module.exports = AsyncValue;